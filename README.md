# 3-SAT-solver-algorithm
Алгоритм  решения задач выполнимости булевой формулы 3-SAT с заранее определенной сложностью

Простой алгоритм, позволяющий решить любую задачу, представленную в виде 3-SAT выражения<br/>
Сложность в лучшем случае O(2n)

1. Создадим пустой массив переменных P. 
2. В выражении выберем переменную xi такую, что бы она входила в максимальное число клозов (дизъюнктов). Запишем эту переменную в массив P. Разделим функцию на две части - в левой части оставим клозы, в которые xi не входит, в правую перенесём все клозы, в которые xi входит. Будем выполнять пункт 2 на левой части функции до тех пор, пока в ней не останется клозов. 
3. Утверждение: перебор переменных массива P всегда обращает исходную функцию в 2SAT выражение, которое решается за линейное время.
4. Полный перебор переменных массива P гарантированно находит решение 3SAT выражения.
5. Лучшее время выполнения определяется сложностью функции и может быть минимально равно O(2n), если первая же выбранная переменная xi входит во все клозы выражения.

![image](https://github.com/user-attachments/assets/59e30b0b-b6b4-43f8-8dff-8506a1138711)

На представленном выше рисунке видно, что при подстановке всех значений в массив P выражение обращается в 2-SAT выражение
Перебирая все варианты в массиве P мы получим все возможные 2-SAT выражения
Решив их мы найдем, что функция или имеет решение или не имеет, если все варианты перебора возвратили 2-SAT выражения, не имеющие решения.


Продолжение развития темы:

Алгоритм, детерминированно решающий задачи 3-ВЫП
Сложность: O(SQRT(2)^n)

Детальное описание алгоритма для 3-SAT с оценкой O(2^{n/2})

I. Предварительная подготовка
Вход: 3-CNF формула F с n переменными x₁, x₂, ..., xₙ и m клаузами.
Выход: Выполняющее присваивание или сообщение о невыполнимости.

II. Лексикографическое разложение (построение множеств P и Q)
Алгоритм строит вершинное покрытие гиперграфа клауз, выбирая на каждом шаге переменную с наименьшим номером.

```text
P := ∅
Активная формула G := F

while G содержит хотя бы одну клаузу:
    Найти клаузу C в G с минимальным значением min{номер переменной | переменная входит в C}
    Пусть x — переменная с наименьшим номером в C
    P := P ∪ {x}
    Удалить из G все клаузы, содержащие x (как в положительном, так и в отрицательном вхождении)

Q := {x₁, ..., xₙ} \ P
```

Свойства разложения:

Каждая исходная клауза содержит хотя бы одну переменную из P

После фиксации всех переменных из P:

Каждая исходная 3-клауза либо становится истинной (если фиксированная переменная удовлетворяет её)

Либо сокращается до дизъюнкции длины ≤2

Следовательно, оставшаяся формула становится 2-CNF на переменных Q

Вычисление сложности разложения: O(n·m) — за один проход по формуле.

III. Выбор стратегии перебора
```text
if |P| ≤ |Q|:
    strategy = "перебор_P"
else:
    strategy = "перебор_Q"
```
Цель: минимизировать экспоненциальный множитель, используя min(2^{|P|}, 2^{|Q|}) ≤ 2^{n/2}.

IV. Стратегия 1: Перебор по P (с решением 2-SAT на Q)
```text
if strategy == "перебор_P":
    for each присваивание α: P → {0,1}:
        F_α := F с подставленными значениями из α
        // F_α является 2-CNF на переменных Q
        result := решить 2-SAT(F_α)  // линейный алгоритм
        if result != "невыполнима":
            β := присваивание из result
            return (α ∪ β)
    return "формула невыполнима"
```
Обоснование: После фиксации α каждая клауза превращается в дизъюнкцию ≤2 литералов, так как удалена хотя бы одна переменная из P. Получаем задачу 2-SAT, решаемую за O(m+n).

V. Стратегия 2: Перебор по Q (с обратным распространением на P)
```text
if strategy == "перебор_Q":
    for each присваивание β: Q → {0,1}:
        F_β := F с подставленными значениями из β
        // F_β имеет специальную структуру на P
        
        // Алгоритм обратного распространения
        Упорядочить переменные P по убыванию исходных номеров: p_k, p_{k-1}, ..., p₁
        инициализировать пустое присваивание γ: P → {0,1, *}  // * — не определено
        
        contradiction := false
        
        for i = k downto 1:
            x := p_i
            // Собрать все клаузы из F_β, содержащие x
            clauses_with_x := все клаузы F_β, где встречается x или ¬x
            
            // Подставить уже определённые значения (переменные с бо́льшими номерами)
            simplified_clauses := []
            for each clause C in clauses_with_x:
                C' := подставить в C значения из γ для всех переменных с номером > x
                // После подстановки C' может быть:
                //  - истинна (содержит истинный литерал)
                //  - ложна (все литералы ложны)
                //  - единичная клауза (один неопределённый литерал)
                //  - двойная клауза (два неопределённых литерала)
                // Но по построению F_β, после подстановки значений из Q,
                // в клаузах остаются только переменные P, причём:
                // если C содержала x, то остальные переменные в C имеют номера > x
                // Поэтому после подстановки γ для переменных > x,
                // C' становится либо истинной, либо единичной клаузой (x или ¬x)
                
                if C' уже истинна:
                    пропустить
                else if C' стала ложной:
                    contradiction := true
                    break
                else if C' стала (x) или (¬x):
                    добавить C' в simplified_clauses
            
            if contradiction:
                break
                
            // Анализ упрощённых клауз
            requires_true := false
            requires_false := false
            
            for each clause in simplified_clauses:
                if clause == (x): requires_true := true
                if clause == (¬x): requires_false := true
            
            if requires_true and requires_false:
                contradiction := true
                break
            elif requires_true:
                γ(x) := 1
            elif requires_false:
                γ(x) := 0
            else:
                // x свободна — можно присвоить любое значение
                γ(x) := 0  // произвольный выбор
        
        if not contradiction:
            // Все неопределённые переменные (если остались) устанавливаем в 0
            for each x in P where γ(x) == *:
                γ(x) := 0
            return (β ∪ γ)
    
    return "формула невыполнима"
```
Корректность алгоритма обратного распространения:

Инвариант: При обработке переменной x все переменные с номерами > x уже обработаны и имеют значения в γ.

Структура клауз: Любая клауза, содержащая x, после подстановки β содержит только переменные с номерами ≥ x. После подстановки значений для переменных с номерами > x, она становится либо истинной, либо единичной клаузой (x или ¬x).

Отсутствие конфликтов: Если для x возникают противоречивые требования (x и ¬x), то формула невыполнима при данном β. В противном случае значение x определяется однозначно или произвольно.

Невлияние на обработанные условия: Выбор значения для x не влияет на уже обработанные условия, так как те зависят только от переменных с бо́льшими номерами.

VI. Анализ сложности
Теорема: Алгоритм решает 3-SAT за время O(2^{n/2} · poly(n, m)).

Доказательство:

Разложение: Построение P и Q требует O(n·m) времени.

Выбор стратегии: O(1).

Стратегия перебора по P:

Число итераций: 2^{|P|} ≤ 2^{n/2} (так как |P| ≤ n/2 при выборе этой стратегии)

На каждой итерации: подстановка O(m) + решение 2-SAT O(n+m)

Итого: O(2^{n/2} · (n+m))

Стратегия перебора по Q:

Число итераций: 2^{|Q|} ≤ 2^{n/2} (так как |Q| < |P| ≤ n/2 при выборе этой стратегии)

На каждой итерации: подстановка O(m) + обратное распространение O(n·m)
(для каждой из |P| переменных обрабатываем все клаузы, содержащие её)

Итого: O(2^{n/2} · n·m)

Общая сложность: O(2^{n/2} · poly(n, m))

VII. Пример работы
Формула: (x₁ ∨ ¬x₂ ∨ x₃) ∧ (¬x₁ ∨ x₂ ∨ x₄) ∧ (x₂ ∨ ¬x₃ ∨ ¬x₄)

Шаг 1: Построение P и Q

Первая клауза: min переменная = x₁, добавляем x₁ в P, удаляем клаузы с x₁

Остаётся только (x₂ ∨ ¬x₃ ∨ ¬x₄)

Минимальная переменная = x₂, добавляем x₂ в P, удаляем оставшуюся клаузу

Результат: P = {x₁, x₂}, Q = {x₃, x₄}

Шаг 2: Выбор стратегии
|P| = 2 ≤ |Q| = 2, выбираем перебор по P

Шаг 3: Перебор по P
Рассмотрим α = {x₁=1, x₂=1}:

Подставляем в формулу:

(1 ∨ ¬1 ∨ x₃) = 1 (истина)

(¬1 ∨ 1 ∨ x₄) = 1 (истина)

(1 ∨ ¬x₃ ∨ ¬x₄) = 1 (истина)
Формула истинна при любых x₃, x₄

Возвращаем решение: {x₁=1, x₂=1, x₃=0, x₄=0}

VIII. Замечания и оптимизации
Порядок переменных: Исходная нумерация влияет на размер P. Можно переупорядочивать переменные для минимизации |P|, но это NP-трудно.

Эвристики: На практике можно:

Выбирать переменную не просто с наименьшим номером, а с максимальной степенью (числом клауз)

Использовать эвристики для выбора порядка обработки клауз

Память: Алгоритм требует полиномиальной памяти.

Параллелизация: Обе стратегии легко параллелизуются по разным присваиваниям.

IX. Заключение
Представленный алгоритм гарантированно решает задачу 3-SAT за время O(2^{n/2} · poly(n, m)), что значительно улучшает наивный перебор O(2ⁿ). Ключевые идеи:

Лексикографическое разложение, выделяющее множество P — вершинное покрытие гиперграфа клауз

Комбинирование двух стратегий перебора для минимизации экспоненты

Использование структуры задачи для сведения к 2-SAT или детерминированной проверке


Заключение:

Алгоритм демонстрирует нетривиальную связь между задачами покрытия гиперграфа и выполнимости булевых формул.



